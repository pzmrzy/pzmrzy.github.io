<!DOCTYPE html>
<html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name ="viewport" content ="width=device-width,initial-scale=1">
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>pzmrzy | Leetcode Report</title>
      <link rel="stylesheet" href="../bootstrap/css/bootstrap.min.css">
      <link rel="stylesheet" href="../bootstrap/css/bootstrap-theme.min.css">
      <link rel="stylesheet" href="../css/prism.css">
      <script type="text/javascript" src="../bootstrap/js/jquery.js"></script>
      <script type="text/javascript" src="../bootstrap/js/bootstrap.min.js"></script>
      <script type="text/javascript" src="../js/prism.js"></script>
    </head>
    <body>
			<div>
				<nav class="navbar navbar-inverse navbar-fixed-top">
					<div class="container">
						<div class="navbar-header">
							<div class="nav navbar-nav"><li><a href="../index.html" id="viewall">Home</a></li></div>
							<div class="nav navbar-nav"><li><a href="../leet.html" id="viewall">Leetcode</a></li></div>
						</div>
					</div>
				</nav>
			</div>
      <br/><br/>
      <div class="container main-container">
        <h3 align = 'middle'>Minimum Size Subarray Sum</h3>
        <div ng-app="app">
  <div class="container">
    <div class="row">
      <div class="col-md-12">

<pre>
Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead.

For example, given the array [2,3,1,2,4,3] and s = 7,
the subarray [4,3] has the minimal length under the problem constraint.

click to show more practice.

More practice:
If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).
</pre>

<b>Report:</b><br />
<pre>
Intuition

Until now, we have kept the starting index of subarray fixed, and found the last position. Instead, we could move the starting index of the current subarray as soon as we know that no better could be done with this index as the starting index. We could keep 2 pointer,one for the start and another for the end of the current subarray, and make optimal moves so as to keep the \text{sum}sum greater than ss as well as maintain the lowest size possible.

Algorithm

Initialize \text{left}left pointer to 0 and \text{sum}sum to 0
Iterate over the \text{nums}nums:
Add \text{nums}[i]nums[i] to \text{sum}sum
While \text{sum}sum is greater than or equal to ss:
Update \text{ans}=\min(\text{ans},i+1-\text{left})ans=min(ans,i+1−left), where i+1-\text{left}i+1−left is the size of current subarray
It means that the first index can safely be incremented, since, the minimum subarray starting with this index with \text{sum} \geq ssum≥s has been achieved
Subtract \text{nums[left]}nums[left] from \text{sum}sum and increment \text{left}left
</pre>
<b>Code:</b><br />
<pre>
  <code class="language-python">
class Solution(object):
    def minSubArrayLen(self, s, nums):
        """
        :type s: int
        :type nums: List[int]
        :rtype: int
        """
        res = float('inf')
        l = summ = 0
        for i in range(len(nums)):
            summ += nums[i]
            while summ >= s:
                res = min(res, i + 1 - l)
                summ -= nums[l]
                l += 1
        return 0 if res == float('inf') else res
  </code>
</pre>
</p>
</p></div></div></div></div></div></div>
    </body>
</html>
