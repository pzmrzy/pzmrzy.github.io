<!DOCTYPE html>
<html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name ="viewport" content ="width=device-width,initial-scale=1">
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>pzmrzy | Leetcode Report</title>
      <link rel="stylesheet" href="../bootstrap/css/bootstrap.min.css">
      <link rel="stylesheet" href="../bootstrap/css/bootstrap-theme.min.css">
      <link rel="stylesheet" href="../css/prism.css">
      <script type="text/javascript" src="../bootstrap/js/jquery.js"></script>
      <script type="text/javascript" src="../bootstrap/js/bootstrap.min.js"></script>
      <script type="text/javascript" src="../js/prism.js"></script>
    </head>
    <body>
			<div>
				<nav class="navbar navbar-inverse navbar-fixed-top">
					<div class="container">
						<div class="navbar-header">
							<div class="nav navbar-nav"><li><a href="../index.html" id="viewall">Home</a></li></div>
							<div class="nav navbar-nav"><li><a href="../leet.html" id="viewall">Leetcode</a></li></div>
						</div>
					</div>
				</nav>
			</div>
      <br/><br/>
      <div class="container main-container">
        <h3 align = 'middle'>Merge k Sorted Lists</h3>
        <div ng-app="app">
  <div class="container">
    <div class="row">
      <div class="col-md-12">

<pre>
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
</pre>

<b>Report:</b><br />
<pre>
Use a heapq to store all the head, key is the val of head, each time pop an element, if it isn't last node in this list, push the next node to the heapq again.
</pre>
<b>Code:</b><br />
<pre>
  <code class="language-python">
    # Definition for singly-linked list.
    # class ListNode(object):
    #     def __init__(self, x):
    #         self.val = x
    #         self.next = None
    from heapq import *
    class Solution(object):
        def mergeKLists(self, lists):
            """
            :type lists: List[ListNode]
            :rtype: ListNode
            """
            head = p = ListNode(-1)
            heap = []
            for i in lists:
                if i:
                    heappush(heap,(i.val,i))
            while heap:
                small = heappop(heap)[1]
                p.next = small
                if small.next:
                    heappush(heap,(small.next.val,small.next))
                p = small
                p.next = None
            return head.next
  </code>
</pre>
</p>
</p></div></div></div></div></div></div>
    </body>
</html>
