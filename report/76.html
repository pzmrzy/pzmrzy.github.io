<!DOCTYPE html>
<html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name ="viewport" content ="width=device-width,initial-scale=1">
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>pzmrzy | Leetcode Report</title>
      <link rel="stylesheet" href="../bootstrap/css/bootstrap.min.css">
      <link rel="stylesheet" href="../bootstrap/css/bootstrap-theme.min.css">
      <link rel="stylesheet" href="../css/prism.css">
      <script type="text/javascript" src="../bootstrap/js/jquery.js"></script>
      <script type="text/javascript" src="../bootstrap/js/bootstrap.min.js"></script>
      <script type="text/javascript" src="../js/prism.js"></script>
    </head>
    <body>
			<div>
				<nav class="navbar navbar-inverse navbar-fixed-top">
					<div class="container">
						<div class="navbar-header">
							<div class="nav navbar-nav"><li><a href="../index.html" id="viewall">Home</a></li></div>
							<div class="nav navbar-nav"><li><a href="../leet.html" id="viewall">Leetcode</a></li></div>
						</div>
					</div>
				</nav>
			</div>
      <br/><br/>
      <div class="container main-container">
        <h3 align = 'middle'>Minimum Window Substring</h3>
        <div ng-app="app">
  <div class="container">
    <div class="row">
      <div class="col-md-12">

<pre>
  Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).

  For example,
  S = "ADOBECODEBANC"
  T = "ABC"
  Minimum window is "BANC".

  Note:
  If there is no such window in S that covers all characters in T, return the empty string "".

  If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.
</pre>
<b>Report:</b><br />
<pre>
The current window is s[i:j] and the result window is s[I:J]. In need[c] I store how many times I need character c (can be negative) and missing tells how many characters are still missing. In the loop, first add the new character to the window. Then, if nothing is missing, remove as much as possible from the window start and then update the result.
</pre>
<b>Code:</b><br />
<pre>
  <code class="language-python">
class Solution(object):
    def minWindow(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: str
        """
        i = j = I = J = 0
        miss = len(t)
        need = collections.Counter(t)
        for c in s:
            j += 1
            if need[c] > 0:
                miss -= 1
            need[c] -= 1
            if miss == 0:
                while i < j and need[s[i]] < 0:
                    need[s[i]] += 1
                    i += 1
                if J == 0 or j - i <= J - I:
                    I, J = i, j
        return s[I:J]
  </code>
</pre>
</p>
</p></div></div></div></div></div></div>
    </body>
</html>
